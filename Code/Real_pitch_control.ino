#include <Servo.h>
#include <math.h>
#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
//-------------- Define global variables ----------------
Servo wingServo;
Adafruit_MPU6050 mpu;
const int SERVO_PIN = 9;// Set this to whatever pin of the arduino the servo is in series with
const int NEUTRAL_COMMANDEDANGLE = 65;
const int MAX_ANGLE = NEUTRAL_COMMANDEDANGLE + 35 ;
const int MIN_ANGLE = NEUTRAL_COMMANDEDANGLE - 35;
int CommandedAngle = NEUTRAL_COMMANDEDANGLE;
const float dtSec = 0.005;// dt in milliseconds for integration and actual angle functions, adjust later
const float maxRateDegPerSec = 350; // calibrated by eye (600/s without load but slowed down)
float elevatorActualDeg = 0;
float pitchDeg = 0;
float Pitch = 0.0;
float PitchRate = 0.0;
float targetPitch = 0.0;
float cumuError = 0.0;
float lastError = 0.0;
float CommandedElevation = 0.0; // very important, this is what we use to compute the actual required deflection based on the PID output
//-------------- Useful constants ----------------
const float a = 10; //just for the pitch calculation, rough estimates based on IRL aircraft
const float b = 3;
float K_p = 3; // PID stuff
const float K_i = 0.0;
const float K_d = 0.0;
float decayRate = 0.0; // just a rate so cumulative error doesn't continue to grow unbounded, can adjust later
//------------- Time parameters ---------------
unsigned long CommandRate_MS =5 ;
unsigned long logRate_MS = 5; 
unsigned long lastCommandUpdate = 0;
unsigned long lastLogUpdate = 0;


int AngleGuard (int angle){ // Guard function against extreme angles
  if (angle > MAX_ANGLE) return MAX_ANGLE;
  if (angle < MIN_ANGLE) return MIN_ANGLE;
  return angle;
}
void LogAndCommand (int angle){
  CommandedAngle = AngleGuard(angle); //the angle passed into this command is the protected bounded angle that is return from the angle guard function
  wingServo.write(CommandedAngle);
}
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200); // start Serial Monitor
  wingServo.attach(SERVO_PIN);
  LogAndCommand(NEUTRAL_COMMANDEDANGLE);   // set to neutral position
  while (!Serial) {
    delay(10);  // Wait for Serial Monitor (safe on Nano)
  }

  Serial.println("Initializing MPU-6050...");

  // Try to initialize the sensor
  if (!mpu.begin()) {
    Serial.println("MPU-6050 not found!");
    while (1) {
      delay(10);  // Halt program safely
    }
  }

 // Configure sensor ranges
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
}

float approachWithRateLimit(float elevatorActualDeg, float CommandedAngle, float maxRateDegPerSec, float dtSec) { // A function that uses servo speed to estimate the true deflection at a point in time
  float e = CommandedAngle - elevatorActualDeg; // compute error
  float maxStep = maxRateDegPerSec * dtSec; // build a tolerance (i.e if estimate for actualDeg close, we can assume actual is now the commanded)
  if (fabs(e) <= maxStep) {
    return CommandedAngle; // reach target this step
  }
  // move toward target by maxStep
  return elevatorActualDeg + (e > 0 ? maxStep : -maxStep);

}
float PIDCommand (float SimPitchDeg, float targetPitch){// PID output, directly mappable to rotation of servo in degrees
  float pitchError = targetPitch - SimPitchDeg; //compute the errors
  
  cumuError = cumuError * decayRate + pitchError * dtSec;
  float Proportional = K_p * pitchError;//degree of elevator per unit error
  float Integral = K_i * cumuError;//degree of elevator per unit cumulative error
  float Derivative = - K_d * PitchRate;//degree of elevator per unit rate of change in error

  lastError = pitchError; // now set the current pitchError to be the lastError for the next time this function is called
  float Output = Proportional + Integral + Derivative;
  return Output;
}
// ---------------- Serial targetPitch handler ----------------
// Allows typing a number (e.g. 10 or -5.5) into the Serial Monitor(generated by ChatGPT)
// and updates targetPitch in real time.
void handleSerialTargetPitch() {

  // Check if at least ONE character has arrived over serial
  if (Serial.available() > 0) {

    // Read characters from the serial buffer and convert them
    // into a floating-point number (stops at newline or space)
    float v = Serial.parseFloat();

    // Flush the rest of the line:
    // parseFloat() leaves the newline '\n' behind, so we remove
    // ALL remaining characters to prevent accidental re-reading
    while (Serial.available() > 0) {
      Serial.read();  // discard one character
    }

    // Overwrite the control reference used by the PID loop
    targetPitch = v;

    // Feedback so you can see what value was accepted
    Serial.print("New targetPitch set to: ");
    Serial.println(targetPitch);
  }
}

void loop() {
  // put your main code here, to run repeatedly:
  sensors_event_t accel, gyro, temp;

  // Read the sensor
  mpu.getEvent(&accel, &gyro, &temp);

  //Get the sensor vector information as variables to be used later for simplification
  float ax = accel.acceleration.x;
  float ay = accel.acceleration.y;
  float az = accel.acceleration.z;
  float pitchDeg = atan2(ay, sqrt (ax*ax + az*az)) * 180.0/PI; 

  handleSerialTargetPitch(); //so can adjust pitch
  unsigned long now = millis(); // this how to log quick AND command angle slowly
  if (now - lastLogUpdate >= logRate_MS){
    elevatorActualDeg = approachWithRateLimit (elevatorActualDeg, CommandedAngle, maxRateDegPerSec, dtSec);
    float pitchDeg = atan2(ay, sqrt (ax*ax + az*az)) * 180.0/PI; 
    CommandedElevation = constrain(PIDCommand (pitchDeg, targetPitch), -35, 35); //the PID output constrained to the max deflections
    CommandedElevation = roundf(CommandedElevation); 
    lastLogUpdate += logRate_MS;
    Serial.print("targetPitch:");
    Serial.print(targetPitch);
    Serial.print(" ElevatorDeflection:");
    Serial.print(elevatorActualDeg - NEUTRAL_COMMANDEDANGLE);
    Serial.print(" SimulatedPitch:");
    Serial.print(pitchDeg);
    Serial.print(" CommandedElevatorDeflection:");
    Serial.println(CommandedElevation);
  }
  if (now - lastCommandUpdate >= CommandRate_MS){// to stop servo twitching beyond is speed, adjust CommandRate_MS until not too much
    lastCommandUpdate += CommandRate_MS;
    CommandedAngle = NEUTRAL_COMMANDEDANGLE + CommandedElevation; //output of PID command is deflection from neutral so add on neutral to give required servo angle
    LogAndCommand (CommandedAngle);
      }
  }
  
 
    
    

   

