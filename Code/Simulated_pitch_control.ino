#include <Servo.h>
#include <math.h>
//-------------- Define global variables ----------------
Servo wingServo;
const int SERVO_PIN = 9;// Set this to whatever pin of the arduino the servo is in series with
const int NEUTRAL_COMMANDEDANGLE = 65;
const int MAX_ANGLE = NEUTRAL_COMMANDEDANGLE + 35 ;
const int MIN_ANGLE = NEUTRAL_COMMANDEDANGLE - 35;
int CommandedAngle = NEUTRAL_COMMANDEDANGLE;
const float dtSec = 0.005;// dt in milliseconds for integration and actual angle functions, adjust later
const float maxRateDegPerSec = 350; // calibrated by eye (600/s without load but slowed down)
float elevatorActualDeg = 0;
float SimPitchDeg = 0;
float Pitch = 0.0;
float PitchRate = 0.0;
float targetPitch = 0.0;
float cumuError = 0.0;
float lastError = 0.0;
float CommandedElevation = 0.0; // very important, this is what we use to compute the actual required deflection based on the PID output
//-------------- Useful constants ----------------
const float a = 10; //just for the pitch calculation, rough estimates based on IRL aircraft
const float b = 5;
const float K_p = 1.3; // PID stuff
float K_i = 0.0;
const float K_d = 0.15;
float decayRate = 0.9998; // just a rate so cumulative error doesn't continue to grow unbounded, can adjust later
//------------- Time parameters ---------------
unsigned long CommandRate_MS =5 ;
unsigned long logRate_MS = 5; 
unsigned long lastCommandUpdate = 0;
unsigned long lastLogUpdate = 0;


int AngleGuard (int angle){ // Guard function against extreme angles
  if (angle > MAX_ANGLE) return MAX_ANGLE;
  if (angle < MIN_ANGLE) return MIN_ANGLE;
  return angle;
}
void LogAndCommand (int angle){
  CommandedAngle = AngleGuard(angle); //the angle passed into this command is the protected bounded angle that is return from the angle guard function
  wingServo.write(CommandedAngle);
}
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200); // start Serial Monitor
  wingServo.attach(SERVO_PIN);
  LogAndCommand(NEUTRAL_COMMANDEDANGLE);   // set to neutral position
}


float approachWithRateLimit(float elevatorActualDeg, float CommandedAngle, float maxRateDegPerSec, float dtSec) { // A function that uses servo speed to estimate the true deflection at a point in time
  float e = CommandedAngle - elevatorActualDeg; // compute error
  float maxStep = maxRateDegPerSec * dtSec; // build a tolerance (i.e if estimate for actualDeg close, we can assume actual is now the commanded)
  if (fabs(e) <= maxStep) {
    return CommandedAngle; // reach target this step
  }
  // move toward target by maxStep
  return elevatorActualDeg + (e > 0 ? maxStep : -maxStep);
}
float simulatedPitch (float elevatorActualDeg, float dtSec){ // simulated pitch using Euler integration

float Deflection = elevatorActualDeg - NEUTRAL_COMMANDEDANGLE;

  float PitchAcceleration = a * Deflection - b * PitchRate;
  PitchRate += PitchAcceleration * dtSec;
  Pitch += PitchRate *dtSec;

  return Pitch;
}
float PIDCommand (float SimPitchDeg, float targetPitch){// PID output, directly mappable to rotation of servo in degrees
  float pitchError = targetPitch - SimPitchDeg; //compute the errors
 if (fabs(pitchError) > 10){
    
   K_i = 0.2;
  } 
  cumuError = cumuError * decayRate + pitchError * dtSec;
  float Proportional = K_p * pitchError;//degree of elevator per unit error
  float Integral = K_i * cumuError;//degree of elevator per unit cumulative error
  float Derivative = - K_d * PitchRate;//degree of elevator per unit rate of change in error

  lastError = pitchError; // now set the current pitchError to be the lastError for the next time this function is called
  float Output = Proportional + Integral + Derivative;
  return Output;
}
// ---------------- Serial targetPitch handler ----------------
// Allows typing a number (e.g. 10 or -5.5) into the Serial Monitor(generated by ChatGPT)
// and updates targetPitch in real time.
void handleSerialTargetPitch() {

  // Check if at least ONE character has arrived over serial
  if (Serial.available() > 0) {

    // Read characters from the serial buffer and convert them
    // into a floating-point number (stops at newline or space)
    float v = Serial.parseFloat();

    // Flush the rest of the line:
    // parseFloat() leaves the newline '\n' behind, so we remove
    // ALL remaining characters to prevent accidental re-reading
    while (Serial.available() > 0) {
      Serial.read();  // discard one character
    }

    // Overwrite the control reference used by the PID loop
    targetPitch = v;

    // Feedback so you can see what value was accepted
    Serial.print("New targetPitch set to: ");
    Serial.println(targetPitch);
  }
}

void loop() {
  // put your main code here, to run repeatedly:
  handleSerialTargetPitch(); //so can adjust pitch
  unsigned long now = millis(); // this how to log quick AND command angle slowly
  if (now - lastLogUpdate >= logRate_MS){
    elevatorActualDeg = approachWithRateLimit (elevatorActualDeg, CommandedAngle, maxRateDegPerSec, dtSec);
    SimPitchDeg = simulatedPitch (elevatorActualDeg, dtSec);
    CommandedElevation = constrain(PIDCommand (SimPitchDeg, targetPitch), -35, 35); //the PID output constrained to the max deflections
    CommandedElevation = roundf(CommandedElevation); 
    lastLogUpdate += logRate_MS;
    Serial.print(millis());
    Serial.print(",");
    Serial.print(targetPitch);
    Serial.print(",");
    Serial.print(SimPitchDeg);
    Serial.print(",");
    Serial.println(CommandedElevation);
  }
  if (now - lastCommandUpdate >= CommandRate_MS){// to stop servo twitching beyond is speed, adjust CommandRate_MS until not too much
    lastCommandUpdate += CommandRate_MS;
    CommandedAngle = NEUTRAL_COMMANDEDANGLE + CommandedElevation; //output of PID command is deflection from neutral so add on neutral to give required servo angle
    LogAndCommand (CommandedAngle);
      }
  }
  
 
    
    

   

